<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">


  <meta name="baidu-site-verification" content="fxfElTgOIE" />








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="true" />








  <meta name="baidu-site-verification" content="true" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android 进程," />










<meta name="description" content="Android 应用保活这是一篇我在网上发现的一篇不错的文章所以转载下来了原文 自己曾经也在这个问题上伤过脑经，前几日刚好有一个北京的哥们在QQ说在做IM类的项目，问我进程保活如何处理比较恰当，决定去总结一下，网上搜索一下进程常驻的方案好多好多，但是很多的方案都是不靠谱的或者不是最好的，结合很多资料，今天总结一下Android进程保活的一些方案，都附有完整的实现源码，有些可能你已经知道，但是有些你">
<meta name="keywords" content="Android 进程">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 进程保活通用方法">
<meta property="og:url" content="https://wublack.github.io/Myselfproject/2017/12/23/Android 进程保活通用方法/index.html">
<meta property="og:site_name" content="记录">
<meta property="og:description" content="Android 应用保活这是一篇我在网上发现的一篇不错的文章所以转载下来了原文 自己曾经也在这个问题上伤过脑经，前几日刚好有一个北京的哥们在QQ说在做IM类的项目，问我进程保活如何处理比较恰当，决定去总结一下，网上搜索一下进程常驻的方案好多好多，但是很多的方案都是不靠谱的或者不是最好的，结合很多资料，今天总结一下Android进程保活的一些方案，都附有完整的实现源码，有些可能你已经知道，但是有些你">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1836169-6021bfa515d37f05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1836169-23a164e920543f25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1836169-26955fbc66eaccfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-07-03T06:07:20.926Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 进程保活通用方法">
<meta name="twitter:description" content="Android 应用保活这是一篇我在网上发现的一篇不错的文章所以转载下来了原文 自己曾经也在这个问题上伤过脑经，前几日刚好有一个北京的哥们在QQ说在做IM类的项目，问我进程保活如何处理比较恰当，决定去总结一下，网上搜索一下进程常驻的方案好多好多，但是很多的方案都是不靠谱的或者不是最好的，结合很多资料，今天总结一下Android进程保活的一些方案，都附有完整的实现源码，有些可能你已经知道，但是有些你">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1836169-6021bfa515d37f05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wublack.github.io/Myselfproject/2017/12/23/Android 进程保活通用方法/"/>





  <title>Android 进程保活通用方法 | 记录</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">记录</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">非著名程序员的日常记录</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wublack.github.io/Myselfproject/2017/12/23/Android 进程保活通用方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tim Black">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android 进程保活通用方法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-23T21:41:00+08:00">
                2017-12-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2017/12/23/Android 进程保活通用方法/#SOHUCS" itemprop="discussionUrl">
                  <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2017/12/23/Android 进程保活通用方法/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          
             <span id="/2017/12/23/Android 进程保活通用方法/" class="leancloud_visitors" data-flag-title="Android 进程保活通用方法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Android-应用保活"><a href="#Android-应用保活" class="headerlink" title="Android 应用保活"></a>Android 应用保活</h1><p>这是一篇我在网上发现的一篇不错的文章所以转载下来了<a href="https://blog.csdn.net/u013263323/article/details/56285475" target="_blank" rel="noopener">原文</a></p>
<p>自己曾经也在这个问题上伤过脑经，前几日刚好有一个北京的哥们在QQ说在做IM类的项目，问我进程保活如何处理比较恰当，决定去总结一下，网上搜索一下进程常驻的方案好多好多，但是很多的方案都是不靠谱的或者不是最好的，结合很多资料，今天总结一下Android进程保活的一些方案，都附有完整的实现源码，有些可能你已经知道，但是有些你可能是第一次听说，（1像素Activity，前台服务，账号同步，Jobscheduler,相互唤醒，系统服务捆绑，如果你都了解了，请忽略）经过多方面的验证，Android系统中在没有白名单的情况下做一个任何情况下都不被杀死的应用是基本不可能的，但是我们可以做到我们的应用基本不被杀死，如果杀死可以马上满血复活，原谅我讲的特别含蓄，毕竟现在的技术防不胜防啊，不死应用还是可能的。</p>
<p>有几个问题需要思考，系统为什么会杀掉进程，杀的为什么是我的进程，这是按照什么标准来选择的，是一次性干掉多个进程，还是一个接着一个杀，保活套路一堆，如何进行进程保活才是比较恰当……如果这些问题你还还存在，或许这篇文章可以解答。</p>
<h3 id="一、进程初步了解"><a href="#一、进程初步了解" class="headerlink" title="一、进程初步了解"></a>一、进程初步了解</h3><p>每一个Android应用启动后至少对应一个进程，有的是多个进程，而且主流应用中多个进程的应用比例较大<br><img src="http://upload-images.jianshu.io/upload_images/1836169-6021bfa515d37f05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h4 id="1-如何查看进程解基本信息"><a href="#1-如何查看进程解基本信息" class="headerlink" title="1. 如何查看进程解基本信息"></a>1. 如何查看进程解基本信息</h4><p>对于任何一个进程，我们都可以通过adb shell ps|grep 的方式来查看它的基本信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\admin&gt;adb shell</span><br><span class="line">root@vbox86p:/ # ps|grep com.example.project</span><br><span class="line">u0_a62    1571  125   1064644 88376 00000000 f7714915 S com.example.project:core</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>u0_a62</td>
<td>USER 进程当前用户</td>
</tr>
<tr>
<td>1571</td>
<td>进程ID</td>
</tr>
<tr>
<td>125</td>
<td>进程的父进程ID</td>
</tr>
<tr>
<td>1064644</td>
<td>进程的虚拟内存大小</td>
</tr>
<tr>
<td>88376</td>
<td>实际驻留“在内存中”的内存大小</td>
</tr>
<tr>
<td>com.example.project:core</td>
<td>进程名</td>
</tr>
</tbody>
</table>
<h4 id="2、进程划分"><a href="#2、进程划分" class="headerlink" title="2、进程划分"></a>2、进程划分</h4><p>Android中的进程跟封建社会一样，分了三流九等，Android系统把进程的划为了如下几种（重要性从高到低），网上多位大神都详细总结过（备注：严格来说是划分了6种）。</p>
<h5 id="2-1、前台进程-Foreground-process"><a href="#2-1、前台进程-Foreground-process" class="headerlink" title="2.1、前台进程(Foreground process)"></a>2.1、前台进程(Foreground process)</h5><p>场景： </p>
<ul>
<li>某个进程持有一个正在与用户交互的Activity并且该Activity正处于resume的状态。 </li>
<li>某个进程持有一个Service，并且该Service与用户正在交互的Activity绑定。 </li>
<li>某个进程持有一个Service，并且该Service调用startForeground()方法使之位于前台运行。 </li>
<li>某个进程持有一个Service，并且该Service正在执行它的某个生命周期回调方法，比如onCreate()、 onStart()或onDestroy()。 </li>
<li>某个进程持有一个BroadcastReceiver，并且该BroadcastReceiver正在执行其onReceive()方法。</li>
</ul>
<p>用户正在使用的程序，一般系统是不会杀死前台进程的，除非用户强制停止应用或者系统内存不足等极端情况会杀死。</p>
<h5 id="2-2、可见进程-Visible-process"><a href="#2-2、可见进程-Visible-process" class="headerlink" title="2.2、可见进程(Visible process)"></a>2.2、可见进程(Visible process)</h5><p>场景： </p>
<ul>
<li>拥有不在前台、但仍对用户可见的 Activity（已调用 onPause()）。 </li>
<li>拥有绑定到可见（或前台）Activity 的 Service</li>
</ul>
<p>用户正在使用，看得到，但是摸不着，没有覆盖到整个屏幕,只有屏幕的一部分可见进程不包含任何前台组件，一般系统也是不会杀死可见进程的，除非要在资源吃紧的情况下，要保持某个或多个前台进程存活</p>
<h5 id="2-3、服务进程-Service-process"><a href="#2-3、服务进程-Service-process" class="headerlink" title="2.3、服务进程(Service process)"></a>2.3、服务进程(Service process)</h5><p>场景 </p>
<ul>
<li>某个进程中运行着一个Service且该Service是通过startService()启动的，与用户看见的界面没有直接关联。</li>
</ul>
<p>在内存不足以维持所有前台进程和可见进程同时运行的情况下，服务进程会被杀死</p>
<h5 id="2-4、后台进程-Background-process"><a href="#2-4、后台进程-Background-process" class="headerlink" title="2.4、后台进程(Background process)"></a>2.4、后台进程(Background process)</h5><p>场景： </p>
<ul>
<li>在用户按了”back”或者”home”后,程序本身看不到了,但是其实还在运行的程序，比如Activity调用了onPause方法</li>
</ul>
<p>系统可能随时终止它们，回收内存</p>
<h5 id="2-5、空进程-Empty-process"><a href="#2-5、空进程-Empty-process" class="headerlink" title="2.5、空进程(Empty process)"></a>2.5、空进程(Empty process)</h5><p>场景： </p>
<ul>
<li>某个进程不包含任何活跃的组件时该进程就会被置为空进程，完全没用,杀了它只有好处没坏处,第一个干它!</li>
</ul>
<h4 id="3、内存阈值"><a href="#3、内存阈值" class="headerlink" title="3、内存阈值"></a>3、内存阈值</h4><p>上面是进程的分类，进程是怎么被杀的呢？系统出于体验和性能上的考虑，app在退到后台时系统并不会真正的kill掉这个进程，而是将其缓存起来。打开的应用越多，后台缓存的进程也越多。在系统内存不足的情况下，系统开始依据自身的一套进程回收机制来判断要kill掉哪些进程，以腾出内存来供给需要的app, 这套杀进程回收内存的机制就叫 Low Memory Killer。那这个不足怎么来规定呢，那就是内存阈值，我们可以使用cat /sys/module/lowmemorykiller/parameters/minfree来查看某个手机的内存阈值。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vbox86p:/ #  cat /sys/module/lowmemorykiller/parameters/minfree</span><br><span class="line">18432，23040，27648，32256，36864，46080</span><br></pre></td></tr></table></figure>
<p>注意这些数字的单位是page. 1 page = 4 kb.上面的六个数字对应的就是(MB): 72,90,108,126,144,180，这些数字也就是对应的内存阀值,内存阈值在不同的手机上不一样，一旦低于该值,Android便开始按顺序关闭进程. 因此Android开始结束优先级最低的空进程，即当可用内存小于180MB(46080*4/1024)。</p>
<p>读到这里，你或许有一个疑问，假设现在内存不足，空进程都被杀光了，现在要杀后台进程，但是手机中后台进程很多，难道要一次性全部都清理掉？当然不是的，进程是有它的优先级的，这个优先级通过进程的adj值来反映，它是linux内核分配给每个系统进程的一个值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收，adj值定义在com.android.server.am.ProcessList类中，这个类路径是${android-sdk-path}\sources\android-23\com\android\server\am\ProcessList.java。oom_adj的值越小，进程的优先级越高，普通进程oom_adj值是大于等于0的，而系统进程oom_adj的值是小于0的，我们可以通过cat /proc/进程id/oom_adj可以看到当前进程的adj值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1|root@vbox86p:/ # ps|grep com.example.project</span><br><span class="line">u0_a62    1630  126   1062596 90144 00000000 f7759915 S com.pty.project</span><br><span class="line">root@vbox86p:/ # cat /proc/1630/oom_adj</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>看到adj值是0，0就代表这个进程是属于前台进程，我们按下Back键，将应用至于后台，再次查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vbox86p:/ # cat /proc/1887/oom_adj</span><br><span class="line">0</span><br><span class="line">root@vbox86p:/ # cat /proc/1887/oom_adj</span><br><span class="line">8</span><br></pre></td></tr></table></figure></p>
<p>adj值变成了8，8代表这个进程是属于不活跃的进程，你可以尝试其他情况下，oom_adj值是多少，但是每个手机的厂商可能不一样，oom_adj值主要有这么几个，可以参考一下。</p>
<table>
<thead>
<tr>
<th>adj级别</th>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNKNOWN_ADJ</td>
<td>16</td>
<td>预留的最低级别，一般对于缓存的进程才有可能设置成这个级别</td>
</tr>
<tr>
<td>CACHED_APP_MAX_ADJ</td>
<td>15</td>
<td>缓存进程，空进程，在内存不足的情况下就会优先被kill</td>
</tr>
<tr>
<td>CACHED_APP_MIN_ADJ</td>
<td>9</td>
<td>缓存进程，也就是空进程</td>
</tr>
<tr>
<td>SERVICE_B_ADJ</td>
<td>8</td>
<td>不活跃的进程</td>
</tr>
<tr>
<td>PREVIOUS_APP_ADJ</td>
<td>7</td>
<td>切换进程</td>
</tr>
<tr>
<td>HOME_APP_ADJ</td>
<td>6</td>
<td>与Home交互的进程</td>
</tr>
<tr>
<td>SERVICE_ADJ</td>
<td>5</td>
<td>有Service的进程</td>
</tr>
<tr>
<td>HEAVY_WEIGHT_AP6P_ADJ</td>
<td>4</td>
<td>高权重进程</td>
</tr>
<tr>
<td>BACKUP_APP_ADJ</td>
<td>3</td>
<td>正在备份的进程</td>
</tr>
<tr>
<td>PERCEPTIBLE_APP_ADJ</td>
<td>2</td>
<td>可感知的进程，比如那种播放音乐</td>
</tr>
<tr>
<td>VISIBLE_APP_ADJ</td>
<td>1</td>
<td>可见进程</td>
</tr>
<tr>
<td>FOREGROUND_APP_ADJ</td>
<td>0</td>
<td>前台进程</td>
</tr>
<tr>
<td>PERSISTENT_SERVICE_ADJ</td>
<td>-11</td>
<td>重要进程</td>
</tr>
<tr>
<td>PERSISTENT_PROC_ADJ</td>
<td>-12</td>
<td>核心进程</td>
</tr>
<tr>
<td>SYSTEM_ADJ</td>
<td>-16</td>
<td>系统进程</td>
</tr>
<tr>
<td>NATIVE_ADJ</td>
<td>-17</td>
<td>系统起的Native进程</td>
</tr>
</tbody>
</table>
<p>备注：（上表的数字可能在不同系统会有一定的出入）</p>
<p>根据上面的adj值，其实系统在进程回收跟内存回收类似也是有一套严格的策略，可以自己去了解，大概是这个样子的，oom_adj越大，占用物理内存越多会被最先kill掉，OK，那么现在对于进程如何保活这个问题就转化成，如何降低oom_adj的值，以及如何使得我们应用占的内存最少。</p>
<h3 id="二、进程保活方案"><a href="#二、进程保活方案" class="headerlink" title="二、进程保活方案"></a>二、进程保活方案</h3><h4 id="1、开启一个像素的Activity"><a href="#1、开启一个像素的Activity" class="headerlink" title="1、开启一个像素的Activity"></a>1、开启一个像素的Activity</h4><p>据说这个是手Q的进程保活方案，基本思想，系统一般是不会杀死前台进程的。所以要使得进程常驻，我们只需要在锁屏的时候在本进程开启一个Activity，为了欺骗用户，让这个Activity的大小是1像素，并且透明无切换动画，在开屏幕的时候，把这个Activity关闭掉，所以这个就需要监听系统锁屏广播，我试过了，的确好使，如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果直接启动一个Activity，当我们按下back键返回桌面的时候，oom_adj的值是8，上面已经提到过，这个进程在资源不够的情况下是容易被回收的。现在造一个一个像素的Activity。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class LiveActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    public static final String TAG = LiveActivity.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    public static void actionToLiveActivity(Context pContext) &#123;</span><br><span class="line">        Intent intent = new Intent(pContext, LiveActivity.class);</span><br><span class="line">        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        pContext.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        Log.d(TAG, &quot;onCreate&quot;);</span><br><span class="line">        setContentView(R.layout.activity_live);</span><br><span class="line"></span><br><span class="line">        Window window = getWindow();</span><br><span class="line">        //放在左上角</span><br><span class="line">        window.setGravity(Gravity.START | Gravity.TOP);</span><br><span class="line">        WindowManager.LayoutParams attributes = window.getAttributes();</span><br><span class="line">        //宽高设计为1个像素</span><br><span class="line">        attributes.width = 1;</span><br><span class="line">        attributes.height = 1;</span><br><span class="line">        //起始坐标</span><br><span class="line">        attributes.x = 0;</span><br><span class="line">        attributes.y = 0;</span><br><span class="line">        window.setAttributes(attributes);</span><br><span class="line"></span><br><span class="line">        ScreenManager.getInstance(this).setActivity(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        Log.d(TAG, &quot;onDestroy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了做的更隐藏，最好设置一下这个Activity的主题，当然也无所谓了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;LiveStyle&quot;&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@null&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>在屏幕关闭的时候把LiveActivity启动起来，在开屏的时候把LiveActivity 关闭掉，所以要监听系统锁屏广播，以接口的形式通知MainActivity启动或者关闭LiveActivity。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class ScreenBroadcastListener &#123;</span><br><span class="line"></span><br><span class="line">    private Context mContext;</span><br><span class="line"></span><br><span class="line">    private ScreenBroadcastReceiver mScreenReceiver;</span><br><span class="line"></span><br><span class="line">    private ScreenStateListener mListener;</span><br><span class="line"></span><br><span class="line">    public ScreenBroadcastListener(Context context) &#123;</span><br><span class="line">        mContext = context.getApplicationContext();</span><br><span class="line">        mScreenReceiver = new ScreenBroadcastReceiver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface ScreenStateListener &#123;</span><br><span class="line"></span><br><span class="line">        void onScreenOn();</span><br><span class="line"></span><br><span class="line">        void onScreenOff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * screen状态广播接收者</span><br><span class="line">     */</span><br><span class="line">    private class ScreenBroadcastReceiver extends BroadcastReceiver &#123;</span><br><span class="line">        private String action = null;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">            action = intent.getAction();</span><br><span class="line">            if (Intent.ACTION_SCREEN_ON.equals(action)) &#123; // 开屏</span><br><span class="line">                mListener.onScreenOn();</span><br><span class="line">            &#125; else if (Intent.ACTION_SCREEN_OFF.equals(action)) &#123; // 锁屏</span><br><span class="line">                mListener.onScreenOff();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void registerListener(ScreenStateListener listener) &#123;</span><br><span class="line">        mListener = listener;</span><br><span class="line">        registerListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void registerListener() &#123;</span><br><span class="line">        IntentFilter filter = new IntentFilter();</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_ON);</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">        mContext.registerReceiver(mScreenReceiver, filter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class ScreenManager &#123;</span><br><span class="line"></span><br><span class="line">    private Context mContext;</span><br><span class="line"></span><br><span class="line">    private WeakReference&lt;Activity&gt; mActivityWref;</span><br><span class="line"></span><br><span class="line">    public static ScreenManager gDefualt;</span><br><span class="line"></span><br><span class="line">    public static ScreenManager getInstance(Context pContext) &#123;</span><br><span class="line">        if (gDefualt == null) &#123;</span><br><span class="line">            gDefualt = new ScreenManager(pContext.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">        return gDefualt;</span><br><span class="line">    &#125;</span><br><span class="line">    private ScreenManager(Context pContext) &#123;</span><br><span class="line">        this.mContext = pContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setActivity(Activity pActivity) &#123;</span><br><span class="line">        mActivityWref = new WeakReference&lt;Activity&gt;(pActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void startActivity() &#123;</span><br><span class="line">            LiveActivity.actionToLiveActivity(mContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void finishActivity() &#123;</span><br><span class="line">        //结束掉LiveActivity</span><br><span class="line">        if (mActivityWref != null) &#123;</span><br><span class="line">            Activity activity = mActivityWref.get();</span><br><span class="line">            if (activity != null) &#123;</span><br><span class="line">                activity.finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在MainActivity改成如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        final ScreenManager screenManager = ScreenManager.getInstance(MainActivity.this);</span><br><span class="line">        ScreenBroadcastListener listener = new ScreenBroadcastListener(this);</span><br><span class="line">         listener.registerListener(new ScreenBroadcastListener.ScreenStateListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onScreenOn() &#123;</span><br><span class="line">                screenManager.finishActivity();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onScreenOff() &#123;</span><br><span class="line">                screenManager.startActivity();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vbox86p:/ # cat /proc/1887/oom_adj</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>果然将进程的优先级提高了。</p>
<p>但是还有一个问题，内存也是一个考虑的因素，内存越多会被最先kill掉，所以把上面的业务逻辑放到Service中，而Service是在另外一个 进程中，在MainActivity开启这个服务就行了，这样这个进程就更加的轻量，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class LiveService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    public  static void toLiveService(Context pContext)&#123;</span><br><span class="line">        Intent intent=new Intent(pContext,LiveService.class);</span><br><span class="line">        pContext.startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        //屏幕关闭的时候启动一个1像素的Activity，开屏的时候关闭Activity</span><br><span class="line">        final ScreenManager screenManager = ScreenManager.getInstance(LiveService.this);</span><br><span class="line">        ScreenBroadcastListener listener = new ScreenBroadcastListener(this);</span><br><span class="line">        listener.registerListener(new ScreenBroadcastListener.ScreenStateListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onScreenOn() &#123;</span><br><span class="line">                screenManager.finishActivity();</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onScreenOff() &#123;</span><br><span class="line">                screenManager.startActivity();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return START_REDELIVER_INTENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=&quot;.LiveService&quot;</span><br><span class="line">            android:process=&quot;:live_service&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>OK，通过上面的操作，我们的应用就始终和前台进程是一样的优先级了，为了省电，系统检测到锁屏事件后一段时间内会杀死后台进程，如果采取这种方案，就可以避免了这个问题。但是还是有被杀掉的可能，所以我们还需要做双进程守护，关于双进程守护，比较适合的就是aidl的那种方式，但是这个不是完全的靠谱，原理是A进程死的时候，B还在活着，B可以将A进程拉起来，反之，B进程死的时候，A还活着，A可以将B拉起来。所以双进程守护的前提是，系统杀进程只能一个个的去杀，如果一次性杀两个，这种方法也是不OK的。</p>
<p>事实上<br>那么我们先来看看Android5.0以下的源码，ActivityManagerService是如何关闭在应用退出后清理内存的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process.killProcessQuiet(pid);</span><br></pre></td></tr></table></figure></p>
<p>应用退出后，ActivityManagerService就把主进程给杀死了，但是，在Android5.0以后，ActivityManagerService却是这样处理的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Process.killProcessQuiet(app.pid);  </span><br><span class="line">Process.killProcessGroup(app.info.uid, app.pid);</span><br></pre></td></tr></table></figure></p>
<p>在应用退出后，ActivityManagerService不仅把主进程给杀死，另外把主进程所属的进程组一并杀死，这样一来，由于子进程和主进程在同一进程组，子进程在做的事情，也就停止了。所以在Android5.0以后的手机应用在进程被杀死后，要采用其他方案。</p>
<h4 id="2、前台服务"><a href="#2、前台服务" class="headerlink" title="2、前台服务"></a>2、前台服务</h4><p>这种大部分人都了解，据说这个微信也用过的进程保活方案，移步<a href="http://mt.sohu.com/20160408/n443685317.shtml" target="_blank" rel="noopener">微信Android客户端后台保活经验分享</a>，这方案实际利用了Android前台service的漏洞。<br>原理如下<br>对于 API level &lt; 18 ：调用startForeground(ID， new Notification())，发送空的Notification ，图标则不会显示。<br>对于 API level &gt;= 18：在需要提优先级的service A启动一个InnerService，两个服务同时startForeground，且绑定同样的 ID。Stop 掉InnerService ，这样通知栏图标即被移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class KeepLiveService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    public static final int NOTIFICATION_ID=0x11;</span><br><span class="line"></span><br><span class="line">    public KeepLiveService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;Not yet implemented&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">         //API 18以下，直接发送Notification并将其置为前台</span><br><span class="line">        if (Build.VERSION.SDK_INT &lt;Build.VERSION_CODES.JELLY_BEAN_MR2) &#123;</span><br><span class="line">            startForeground(NOTIFICATION_ID, new Notification());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //API 18以上，发送Notification并将其置为前台后，启动InnerService</span><br><span class="line">            Notification.Builder builder = new Notification.Builder(this);</span><br><span class="line">            builder.setSmallIcon(R.mipmap.ic_launcher);</span><br><span class="line">            startForeground(NOTIFICATION_ID, builder.build());</span><br><span class="line">            startService(new Intent(this, InnerService.class));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  class  InnerService extends Service&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public IBinder onBind(Intent intent) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void onCreate() &#123;</span><br><span class="line">            super.onCreate();</span><br><span class="line">            //发送与KeepLiveService中ID相同的Notification，然后将其取消并取消自己的前台显示</span><br><span class="line">            Notification.Builder builder = new Notification.Builder(this);</span><br><span class="line">            builder.setSmallIcon(R.mipmap.ic_launcher);</span><br><span class="line">            startForeground(NOTIFICATION_ID, builder.build());</span><br><span class="line">            new Handler().postDelayed(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    stopForeground(true);</span><br><span class="line">                    NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">                    manager.cancel(NOTIFICATION_ID);</span><br><span class="line">                    stopSelf();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,100);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有采取前台服务之前，启动应用，oom_adj值是0，按下返回键之后，变成9（不同ROM可能不一样）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vbox86p:/ # cat /proc/1887/oom_adj</span><br><span class="line">0</span><br><span class="line">root@vbox86p:/ # cat /proc/1887/oom_adj</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>在采取前台服务之后，启动应用，oom_adj值是0，按下返回键之后，变成2（不同ROM可能不一样），确实进程的优先级有所提高。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vbox86p:/ # cat /proc/1887/oom_adj</span><br><span class="line">0</span><br><span class="line">root@vbox86p:/ # cat /proc/1887/oom_adj</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h4 id="3、相互唤醒"><a href="#3、相互唤醒" class="headerlink" title="3、相互唤醒"></a>3、相互唤醒</h4><p>相互唤醒的意思就是，假如你手机里装了支付宝、淘宝、天猫、UC等阿里系的app，那么你打开任意一个阿里系的app后，有可能就顺便把其他阿里系的app给唤醒了。这个完全有可能的。此外，开机，网络切换、拍照、拍视频时候，利用系统产生的广播也能唤醒app，不过Android N已经将这三种广播取消了。<br><img src="http://upload-images.jianshu.io/upload_images/1836169-23a164e920543f25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="http://upload-images.jianshu.io/upload_images/1836169-26955fbc66eaccfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>如果应用想保活，要是QQ，微信愿意救你也行，有多少手机上没有QQ，微信呢？或者像友盟，信鸽这种推送SDK，也存在唤醒app的功能。<br>拉活方法</p>
<h4 id="4、JobSheduler"><a href="#4、JobSheduler" class="headerlink" title="4、JobSheduler"></a>4、JobSheduler</h4><p>JobSheduler是作为进程死后复活的一种手段，native进程方式最大缺点是费电， Native 进程费电的原因是感知主进程是否存活有两种实现方式，在 Native 进程中通过死循环或定时器，轮训判断主进程是否存活，当主进程不存活时进行拉活。其次5.0以上系统不支持。 但是JobSheduler可以替代在Android5.0以上native进程方式，这种方式即使用户强制关闭，也能被拉起来，亲测可行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">JobSheduler@TargetApi(Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">public class MyJobService extends JobService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        startJobSheduler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void startJobSheduler() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            JobInfo.Builder builder = new JobInfo.Builder(1, new ComponentName(getPackageName(), MyJobService.class.getName()));</span><br><span class="line">            builder.setPeriodic(5);</span><br><span class="line">            builder.setPersisted(true);</span><br><span class="line">            JobScheduler jobScheduler = (JobScheduler) this.getSystemService(Context.JOB_SCHEDULER_SERVICE);</span><br><span class="line">            jobScheduler.schedule(builder.build());</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStartJob(JobParameters jobParameters) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStopJob(JobParameters jobParameters) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、粘性服务-amp-与系统服务捆绑"><a href="#5、粘性服务-amp-与系统服务捆绑" class="headerlink" title="5、粘性服务&amp;与系统服务捆绑"></a>5、粘性服务&amp;与系统服务捆绑</h4><p>这个是系统自带的，onStartCommand方法必须具有一个整形的返回值，这个整形的返回值用来告诉系统在服务启动完毕后，如果被Kill，系统将如何操作，这种方案虽然可以，但是在某些情况or某些定制ROM上可能失效，我认为可以多做一种保保守方案。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">    return START_REDELIVER_INTENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>START_STICKY<br>如果系统在onStartCommand返回后被销毁，系统将会重新创建服务并依次调用onCreate和onStartCommand（注意：根据测试Android2.3.3以下版本只会调用onCreate根本不会调用onStartCommand，Android4.0可以办到），这种相当于服务又重新启动恢复到之前的状态了）。</p>
</li>
<li><p>START_NOT_STICKY<br>如果系统在onStartCommand返回后被销毁，如果返回该值，则在执行完onStartCommand方法后如果Service被杀掉系统将不会重启该服务。</p>
</li>
<li><p>START_REDELIVER_INTENT<br>START_STICKY的兼容版本，不同的是其不保证服务被杀后一定能重启。</p>
</li>
</ul>
<p>相比与粘性服务与系统服务捆绑更厉害一点，这个来自爱哥的研究，这里说的系统服务很好理解，比如NotificationListenerService，NotificationListenerService就是一个监听通知的服务，只要手机收到了通知，NotificationListenerService都能监听到，即时用户把进程杀死，也能重启，所以说要是把这个服务放到我们的进程之中，那么就可以呵呵了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)</span><br><span class="line">public class LiveService extends NotificationListenerService &#123;</span><br><span class="line"></span><br><span class="line">    public LiveService() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNotificationPosted(StatusBarNotification sbn) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNotificationRemoved(StatusBarNotification sbn) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种方式需要权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">            android:name=&quot;.LiveService&quot;</span><br><span class="line">            android:permission=&quot;android.permission.BIND_NOTIFICATION_LISTENER_SERVICE&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.service.notification.NotificationListenerService&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/service&gt;</span><br></pre></td></tr></table></figure></p>
<p>所以你的应用要是有消息推送的话，那么可以用这种方式去欺骗用户。</p>
<p>结束：<br>听说账号同步唤醒APP这种机制很不错，用户强制停止都杀不起创建一个账号并设置同步器，创建周期同步，系统会自动调用同步器，这样就能激活我们的APP，局限是国产机会修改最短同步周期（魅蓝NOTE2长达30分钟），并且需要联网才能使用。在国内各大ROM”欣欣向荣”的大背景下，关于进程保活，不加入白名单，我也很想知道有没有一个应用永活的方案，这种方案性能好，不费电，或许做不到，或许有牛人可以，但是，通过上面几种措施，在绝大部分的机型下，绝大部分用户手机中，我们的进程寿命确实得到了提高。<br>参考链接：</p>
<p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0418/4158.html" target="_blank" rel="noopener">关于 Android 进程保活，你所需要知道的一切http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0418/4158.html</a></p>
<p><a href="http://blog.csdn.net/aigestudio/article/details/51348408" target="_blank" rel="noopener">论Android应用进程长存的可行性http://blog.csdn.net/aigestudio/article/details/51348408</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjE3OTYwMg==&amp;mid=401629367&amp;idx=1&amp;sn=9f086cfdc00f954e21e6a6253f1ae288&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Android 通过JNI实现守护进程，使Service服务不被杀死 http://mp.weixin.qq.com/s?__biz=MzI0MjE3OTYwMg==&amp;mid=401629367&amp;idx=1&amp;sn=9f086cfdc00f954e21e6a6253f1ae288&amp;scene=21#wechat_redirect</a></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Donate comment here</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Tim Black 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="Tim Black 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android-进程/" rel="tag"># Android 进程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/20/React-Native 与Android原生混合开发交互/" rel="next" title="React-Native与Android原生混合开发交互">
                <i class="fa fa-chevron-left"></i> React-Native与Android原生混合开发交互
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/02/手把手搭建一个免费的vpn/" rel="prev" title="手把手搭建一个免费的Vpn">
                手把手搭建一个免费的Vpn <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="SOHUCS"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Tim Black</p>
              <p class="site-description motion-element" itemprop="description">发现问题，解决问题，记录问题，然后要么无量，要么凉凉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/wublack" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:wl52056@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/115709257208465562340" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-globe"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/people/%E5%90%B4%E4%BA%AE/100015328742846" target="_blank" title="FB Page">
                      
                        <i class="fa fa-fw fa-globe"></i>FB Page</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Android-应用保活"><span class="nav-number">1.</span> <span class="nav-text">Android 应用保活</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、进程初步了解"><span class="nav-number">1.0.1.</span> <span class="nav-text">一、进程初步了解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-如何查看进程解基本信息"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">1. 如何查看进程解基本信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、进程划分"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">2、进程划分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1、前台进程-Foreground-process"><span class="nav-number">1.0.1.2.1.</span> <span class="nav-text">2.1、前台进程(Foreground process)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2、可见进程-Visible-process"><span class="nav-number">1.0.1.2.2.</span> <span class="nav-text">2.2、可见进程(Visible process)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3、服务进程-Service-process"><span class="nav-number">1.0.1.2.3.</span> <span class="nav-text">2.3、服务进程(Service process)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4、后台进程-Background-process"><span class="nav-number">1.0.1.2.4.</span> <span class="nav-text">2.4、后台进程(Background process)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5、空进程-Empty-process"><span class="nav-number">1.0.1.2.5.</span> <span class="nav-text">2.5、空进程(Empty process)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、内存阈值"><span class="nav-number">1.0.1.3.</span> <span class="nav-text">3、内存阈值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、进程保活方案"><span class="nav-number">1.0.2.</span> <span class="nav-text">二、进程保活方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、开启一个像素的Activity"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">1、开启一个像素的Activity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、前台服务"><span class="nav-number">1.0.2.2.</span> <span class="nav-text">2、前台服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、相互唤醒"><span class="nav-number">1.0.2.3.</span> <span class="nav-text">3、相互唤醒</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、JobSheduler"><span class="nav-number">1.0.2.4.</span> <span class="nav-text">4、JobSheduler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、粘性服务-amp-与系统服务捆绑"><span class="nav-number">1.0.2.5.</span> <span class="nav-text">5、粘性服务&amp;与系统服务捆绑</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tim Black</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  




  
    <script type="text/javascript">
    (function(){
      var appid = 'cytH6kFYc';
      var conf = 'e4d8d2a6d8bec5ad7e58f49bd7ec5dcc';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){
        window.changyan.api.config({appid:appid,conf:conf})});
      }
    })();
    </script>
    <script type="text/javascript" src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>
  









  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("VuNyHTWivudmJoqcPo1Kw9HV-gzGzoHsz", "fMEYfcAU83rAR5unJ7CLI2Qg");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
